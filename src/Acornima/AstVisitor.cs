using System;
using System.Runtime.CompilerServices;
using Acornima.Ast;
using Acornima.Helpers;

namespace Acornima;

[AutoGeneratedAstVisitor]
public partial class AstVisitor
{
    private static NotImplementedException UnsupportedNodeType(Type nodeType, [CallerMemberName] string? callerName = null) =>
        new NotImplementedException(string.Format(null, ExceptionMessages.UnsupportedNodeTypeVisited, nodeType, callerName));

    private int _recursionDepth;

    public virtual object? Visit(Node node)
    {
        _recursionDepth++;
        StackGuard.EnsureSufficientExecutionStack(_recursionDepth);

        var result = node.Accept(this);

        _recursionDepth--;
        return result;
    }

    protected internal virtual object? VisitAssignmentProperty(AssignmentProperty node)
    {
        if (!node.Shorthand)
        {
            Visit(node.Key);
        }

        Visit(node.Value);

        return node;
    }

    protected internal virtual object? VisitExportSpecifier(ExportSpecifier node)
    {
        Visit(node.Local);

        if (!ReferenceEquals(node.Exported, node.Local))
        {
            Visit(node.Exported);
        }

        return node;
    }

    protected internal virtual object? VisitExtension(Node node)
    {
        // Node type Extension is used to represent extensions to the standard AST (for example, see JSX parsing).
        // Nodes of this type never appear in the tree returned by the core parser (Parser),
        // thus the visitor doesn't deal with this type by default. Inheritors either need to override this method,
        // or inherit from another visitor which was built to handle extension nodes (e.g. JsxAstVisitor in the case of JSX).

        throw UnsupportedNodeType(node.GetType());
    }

    protected internal virtual object? VisitImportSpecifier(ImportSpecifier node)
    {
        if (!ReferenceEquals(node.Imported, node.Local))
        {
            Visit(node.Imported);
        }

        Visit(node.Local);

        return node;
    }

    protected internal virtual object? VisitObjectProperty(ObjectProperty node)
    {
        if (!node.Shorthand)
        {
            Visit(node.Key);
        }

        Visit(node.Value);

        return node;
    }

    protected internal virtual object? VisitTemplateLiteral(TemplateLiteral node)
    {
        ref readonly var quasis = ref node.Quasis;
        ref readonly var expressions = ref node.Expressions;

        TemplateElement quasi;
        for (var i = 0; !(quasi = quasis[i]).Tail; i++)
        {
            Visit(quasi);
            Visit(expressions[i]);
        }
        Visit(quasi);

        return node;
    }
}
